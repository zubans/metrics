package main

import (
	"fmt"
	"go/format"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

func main() {
	buildVersion := getGitTag()
	buildDate := getBuildDate()
	buildCommit := getGitCommit()

	var sb strings.Builder
	fmt.Fprintf(&sb, "%s", `// Code generated by go generate; DO NOT EDIT.
// This file was generated by cmd/genversion/main.go

package version

const (
`)
	fmt.Fprintf(&sb, "	BuildVersion = %q\n", buildVersion)
	fmt.Fprintf(&sb, "	BuildDate = %q\n", buildDate)
	fmt.Fprintf(&sb, "	BuildCommit = %q\n", buildCommit)
	fmt.Fprintf(&sb, ")")

	generated := []byte(sb.String())
	formatted, err := format.Source(generated)
	if err != nil {
		panic(err)
	}

	currentDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	var outputPath string
	if strings.HasSuffix(currentDir, "internal/version") {
		outputPath = filepath.Join(currentDir, "version_generated.go")
	} else {
		outputPath = "internal/version/version_generated.go"
	}

	err = os.WriteFile(outputPath, formatted, 0644)
	if err != nil {
		panic(err)
	}

	fmt.Printf("Build info generated:\n")
	fmt.Printf("  Version: %s\n", buildVersion)
	fmt.Printf("  Date: %s\n", buildDate)
	fmt.Printf("  Commit: %s\n", buildCommit)
}

func getGitTag() string {
	cmd := exec.Command("git", "describe", "--tags", "--abbrev=0")
	output, err := cmd.Output()
	if err != nil {
		return "N/A"
	}
	return strings.TrimSpace(string(output))
}

func getBuildDate() string {
	cmd := exec.Command("date", "-u", "+%Y-%m-%d_%H:%M:%S_UTC")
	output, err := cmd.Output()
	if err != nil {
		return "N/A"
	}
	return strings.TrimSpace(string(output))
}

func getGitCommit() string {
	cmd := exec.Command("git", "rev-parse", "HEAD")
	output, err := cmd.Output()
	if err != nil {
		return "N/A"
	}
	return strings.TrimSpace(string(output))
}
